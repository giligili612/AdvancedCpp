# 字节序
## 字节序，大端字节序与小端字节序
字节序就是字节在内存里的排列顺序，一个数据不止一个字节存储，如int由4个字节存储，long long由8个字节存储，存储字节顺序不同会影响CPU如何解释这些数据。以int为例，不同字节序的机器存储数字1

**大端字节序：**
- 地址：`0x01 0x02 0x03 0x04`
- 数据：`0x00 0x00 0x00 0x01`

**小端字节序：**
- 地址：`0x01 0x02 0x03 0x04`
- 数据：`0x01 0x00 0x00 0x00`

很好辨认两种字节序，把内存地址从左到右递增排列，往里面填相应类型的数字，符合人类直觉的从左到右的就是大端字节序，相反的就是小端字节序。小端字节序的数字以人类的视角看其实是`(0x04)(0x03)(0x02)(0x01)`

为什么字节序重要？

想象一下大端字节序的数字1原封不动的交给小端字节序的机器，那么小端字节序会解释成`0x01000000`（注意这里不是它在内存中的排列，就是字面意义上的十六进制数），即数字16,777,216，这显然不利于计算机通信。

## 网络字节序和主机字节序
为了不同计算机交流，规定网络字节序为大端字节序。

所有主机往网络上发消息时都要把消息转换为大端字节序，也就是从**主机字节序转换到网络字节序**

主机字节序是计算机的方言，现在大多数计算机采用的是小端字节序。

网络字节序是普通话，为方便交流，公共场合要讲普通话！

## 思考题
为什么有小端字节序这种反直觉的东西？为什么计算机大多是小端字节序？

## 字节序示例程序
```c
#include <stdio.h>
void byteorder();

int main(int argc, char* argv[])
{
    byteorder();
    return 0;
}

void byteorder()
{
    union
    {
        unsigned short value;
        unsigned char union_bytes[sizeof(short)];
    }test;
    test.value = 0x0102;
    if((test.union_bytes[0] == 0x01) && (test.union_bytes[1] == 0x02))
    {
        printf("big endian\n");  // 此为大端字节序
    }
    else if((test.union_bytes[0] == 0x02) && (test.union_bytes[1] == 0x01))
    {
        printf("little endian\n");  // 此为小端字节序，多数pc采用这种字节序
    }
    else 
    {
        // 可能是量子计算机
        printf("a bad computer\n");  
    }
}
// 电脑不许使用方言（本电脑字节序）传递信息，必须使用普通话传递信息（网络字节序，统一为大端序）
// 所以电脑和网络交换信息时，总要转换字节序保证信息的准确性，一般是小端字节序（电脑1）——>大端字节序（网络）——>小端字节序（电脑2）
```
## 字节序转换函数
IP地址：32位

端口号：16位

```c
#include <arpa/inet.h>
// 函数命名规则
// h:host    to    n:net    l:long    s:short
uint32_t htonl(uint32_t hostlong);      // host to net long 
uint16_t htons(uint16_t hostshort);     // host to net short
uint32_t ntohl(uint32_t netlong);       // net to host long
uint16_t ntohs(uint16_t netshort);      // net to host short
```
下面是示例，
```c
#include <netinet/in.h>
#include <stdio.h>

void print_4bytes(const char* name, uint32_t value)
{
    printf("%-8s: 0x%08X | Bytes:", name, value);
    unsigned char* p = (unsigned char*)&value;
    for(int i = 0; i < sizeof(value); i++) {
        printf("%02X ", p[i]);
    }
    putc('\n',stdout);
}

void print_2bytes(const char* name, uint16_t value)
{
    printf("%-8s: 0x%04X | Bytes:", name, value);
    unsigned char* p = (unsigned char*)&value;
    for(int i = 0; i < sizeof(value); i++) {
        printf("%02X ", p[i]);
    }
    putc('\n',stdout);
}

int main(int argc, char* argv[])
{
    // 原始值 (主机字节序)
    uint32_t host_long = 0x12345678;
    uint16_t host_short = 0x1234;

    // 转换演示
    printf("=== 32-bit 转换 ===\n");
    print_4bytes("Client", host_long);
    uint32_t net_long = htonl(host_long);  // 主机到网络，host to net long
    print_4bytes("Network", net_long);
    uint32_t back_long = ntohl(net_long);  // 网络回主机，net to host long
    print_4bytes("Server", back_long);

    printf("\n=== 16-bit 转换 ===\n");
    print_2bytes("Client", host_short);
    uint16_t net_short = htons(host_short);  // 主机到网络， host to net short
    print_2bytes("Network", net_short);
    uint16_t back_short = ntohs(net_short);  // 网络回主机，net to host short
    print_2bytes("Server", back_short);
    return 0;
}
// 4字节转换函数一般用于IP地址信息
// 2字节转换函数一般用于端口号信息
// 所有格式化的数据通过网络传输时都要转换为网络字节序
```
