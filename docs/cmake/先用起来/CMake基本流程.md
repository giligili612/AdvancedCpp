# CMake基本流程
CMake总共分为三个步骤，分别是Configure(配置)->Generate(生成)->build(构建)。接下来我们详细解释这三个步骤
## Configure(配置)
此阶段一共做如下事情：
- 从根目录开始解析所有CMakeLists.txt文件，读取项目描述
- 确认编译器、工具链、目标平台(Linux还是Windows)
- 查找依赖库和头文件
- 确定编译选项
- 综合上述所有信息，构建**抽象的目标依赖图**

此阶段在构建目录里输出`CMakeCache.txt`，记录配置结果（编译器路径、库的位置等），此外还会生成一些中间文件

本阶段就像预备会议，主要工作是收集所有信息，确认用什么工具、编译哪些文件、需要哪些库等等

## Generate(生成)
根据配置阶段的结果，生成实际的**构建系统文件**(比如Makefile、build.ninja等)，具体生成何种文件取决于指定的生成器(generator)：
- 如果是 Unix Makefiles，就会生成 Makefile。
- 如果是 Ninja，就会生成 build.ninja。
- 如果是 Visual Studio，就会生成 .sln、.vcxproj。
这些文件包含了所有目标(executable/library)、依赖关系、编译规则

此阶段输出可执行构建系统描述文件(如Makefile)

本阶段就是会议讨论的施工文档，这个文档写明了具体的构建命令，后续由生成器执行这一系列命令即可

### 为什么要有生成阶段？
我刚学习的时候就疑惑：配置和生成看上去像是一个完整大步骤(准备施工图纸)的两个部分，为什么要分成两个阶段？有很多种原因，但此处只说最重要的。因为**CMake是跨平台+多生成器的**！
- 跨平台：我是在地球施工还是在月球施工(Linux、Windows、MacOS)
- 多生成器：由张三施工队施工还是李四施工队施工(Make、Ninja、VS、Xcode...)

配置阶段：我要做什么，需要哪些工具，它是一个抽象的指导意见，而不是具体的施工方案。

如果把生成阶段(确定具体施工方案)合并到领导的会议里面，那就会丧失灵活性。具体施工方案应该由各施工队根据自己所在平台与手头的工具自己制定。

还有些其他原因读者请自行问AI。
## build(构建)
这一步就很好理解了，Linux的make和VS的编译都是这步，所有步骤与工具都清楚了，各位放开手干吧。

## 常用命令对应阶段
- `cmake -S . -B build`：对应配置与生成
- `cmake --build build`：对应构建
### 为什么命令行把前两个阶段合在一起了？
1. 用户体验更好，无需分两步走，就像编译器也不会让你从预处理到生成目标文件再到链接一步一步调用
2. 内部仍然是两步走，内部的两步走有利于跨平台、IDE集成、错误隔离（只在配置阶段报错，生成阶段几乎不报错）
3. 你仍然可以选择一步一步执行，但是一步到位不是更爽么。（如何单步执行请自行学习）
