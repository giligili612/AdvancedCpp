# 编译使用静态库与动态库
## 代码目录结构
```txt
/libs
  /cal
    cal.cc
    cal.h
    CMakeLists.txt
  /test_cal
    test.cc
    CMakeLists.txt
```
### cal目录
::: code-group

```cpp[cal.h]
#ifndef _CAL_H_
#define _CAL_H_

class Cal
{
public:
    static int add(int a, int b);
    static int minus(int a, int b);
};

#endif
```

```cpp[cal.cc]
#include "cal.h"

int Cal::add(int a, int b) { 
    return a + b;
}

int Cal::minus(int a, int b) {
    return a - b;
}
```

```cmake
cmake_minimum_required(VERSION 3.20)
project(calculate)
add_library(calculate STATIC cal.cc) # STATIC代表静态库
```
:::
命令解析：
`add_library(库名 库的类别 源文件)`：用源文件编译库，库的类别有两种
- `STATIC`:静态库
- `SHARED`:动态库
### test_cal目录
::: code-group

```cpp[test.cc]
#include <iostream>
#include "cal.h"
using namespace std;
int main() {
    cout << Cal::add(1, 2) << "\n";
    cout << Cal::minus(2, 1) << "\n";
    return 0;
}
```

```cmake
# 初始代码
cmake_minimum_required(VERSION 3.20)
project(test)
add_executable(test test.cc)
```
:::

## 编译运行
先编译cal目录，cal目录是可以顺利配置(Configure)、生产(Generate)、构建(Build)，具体步骤参照上节

再进入test_cal目录编译，执行`cmake -S . -B build`没有报错，但是继续执行`cmake --build build`就会报错了，报错如下：
```bash
fatal error: cal.h: 没有那个文件或目录
    2 | #include "cal.h"
      |          ^~~~~~~
compilation terminated.
```
这里的问题在于cmake无法找到头文件cal.h，所以我们要告诉cmake去哪里找头文件，修改test_cal下的CMakeLists.txt
```cmake
cmake_minimum_required(VERSION 3.20)
project(test)
# 指定头文件查找路径，此处的路径是相对于本CMakeLists.txt文件的相对路径
include_directories("../cal")
add_executable(test test.cc)
```
再次执行build命令，继续报错：
```bash
/bin/ld: CMakeFiles/test.dir/test.cc.o: in function `main':
test.cc:(.text+0x13): undefined reference to `Cal::add(int, int)'
/bin/ld: test.cc:(.text+0x48): undefined reference to `Cal::minus(int, int)'
collect2: error: ld returned 1 exit status
```
很显然，cmake找到头文件了但是没有找到函数的定义，所以报错`undefined reference`，那么我们继续修改
```cmake
cmake_minimum_required(VERSION 3.20)
project(test)
# 指定头文件查找路径
include_directories("../cal")
# 指定库查找路径
link_directories("../cal/build")

add_executable(test test.cc)

# 指定加载的库，这一句一定要在add_executable之后
# 因为目标必须先被创建再指定什么什么库链接到目标中
target_link_libraries(test calculate)
```
如此我们再build就可以顺利构建程序，直接运行即可
```bash
./build/test 
3
1
```

上面就是编译使用静态库的完整过程，如果要使用动态库，一切东西都可以不变，只需改变cal下的CMakeLists.txt中的`STATIC`为`SHARED`即可

前后两次编译运行，使用静态库时test的大小为16504，使用动态库的大小为16480，库太小了20多个字节看不出差距

## 静态库与动态库
### 什么是库？
库的本质是经过编译的二进制代码的集合，但它不是完整的程序，而是供其他程序调用的代码模块。

我们在本节中写的cal.h、cal.cc编译之后的模块(calculate)就是库，它无法单独运行，但是其他程序可以调用该模块来使用相应的功能。
### 什么是静态库与动态库？
其他程序调用库时会将调用的库编译链接到最终的可执行文件中，如果是静态库，那么程序会将库复制一份放到自己的文件中，它自成一体，无需依赖外界就可以运行。如果是动态库，那么程序运行的时候还要找到其依赖的库(在本节这个依赖的库就是calculate)。

所以你把程序发给别人用的时候，如果你是静态库编译的程序那么这个程序会很大，但是别人拿到手就可以用。如果你是动态库编译的程序，那么这个程序会小的多，但同时你也要把该程序所依赖的库一同发给别人，别人才可以上手就用，否则别人就需要自己准备同样的库环境才能运行该程序。

如果你刚了解这两个概念你可能觉得静态库多方便，动态库怎么这么麻烦。但现实情况是绝大多数软件都是动态库编译链接再发布的，为什么？因为如果你要修改源代码，那么静态库编译链接的软件你每次都要重新编译所有部分，这样不利于开发与更新，而如果你用的是动态库，那么你每次修改哪个模块哪个模块就重新编译一遍就好了，因为动态库链接的程序记录的是库的地址，它自己接口不动、新库的位置不变就不需要重新编译，它在运行的时候再去相应的库里调用方法即可，这种方式有利于开发测试与软件的后续更新，更为方便。

此外，动态库一个库就可以供一百个程序调用，如果是静态库则需要把相同的库复制编译到100个程序当中，显然动态库可以大大节省空间。
### 库的格式
- 静态库：`libx.a`
- 动态库：`libx.so`

**注意到CMakeLists.txt编译链接的语句都只写x,不写前面的lib与后缀**

## 总结
- 利用cmake编译静态库与动态库
  - add_libaray
  - STATIC、SHARED
- 头文件路径
  - include_directories
- 库路径（去哪找库）
  - link_directories
- 指定加载的库（具体链接什么库，一般库路径下有很多库，不会链接所有库的）
  - target_link_libraries
- 动态库与静态库